\chapter{Conclusions}

\section{Summary}
This project has focused on expanding the reach of the Julia language to digitial hardware platforms like FPGAs. The primary goal has been to develop the framework for a HLS flow that transforms Julia source code into HDL. 

\subsubsection{Initial Stages}
The initial stage of the project was reviewing the Julia documentation to get a familiarity with the language, followed by a deeper dive into the source code behind the compiler stages. In parallel with this, a review of exiting HLS solutions was conducted to become familiar with current tools, the stages of tool development, and the typical methods used to generate digital hardware from high-level languages. Using this information, the fundamental sections of a flow were layed out with the Julia typed IR as the first stage. The first plan was to focus on static scheduling techniques. The flow would have contained passes to scheduled the program flow into a FSM, as well as passes to allocate and bind the operations in the typed IR to functional blocks in HDL form. The interface to this planned flow was the CDFG constructed from the typed IR. After initial work with the Julia compiler and further research into the HLS space, dynamic scheduling was suggested as an alternative option to static scheduling with the goal of speeding up the development of the flow. As a result, the planned flow was changed away from static scheduling to dynamic scheduling. It was now possible to incorporate some of the features of the Dynamatic library, specifically the DOT to VHDL converter. This meant that development efforts could be focused on interfacing with the typed IR and producing functionally correct dynamic schedules for the programs. The work that had been carried out developing the SSATools package could still be used with some modifications to prepare the CDFG for input to the Dynamic Scheduling package.

\subsubsection{Implementation Stages}
Implementation began with the SSATools package. Functions were first developed to interact with and manipulate the typed IR before focusing on the creation of the CDFG representation. The focus then was how to combine and condense the information generated by the Julia reflection and compiler methods into a type that could be used as the interface to subsequent stages of the flow. 

The implementation continued with the Dynamic Scheduling package with occasional modifications made to the SSATools package CDFG interface. As part of this process, functions were transformed into their typed IR and manually converted to dynamically scheduled circuits to act as expected outputs. These outputs were compared to results of scheduling and used to fix issues. The test functions chosen at this stage focused included several implementations of a functionally equivalent if-else statement and while loops. The goal was to generate the different forms of branching and control flow that could be implemented in the typed IR.

\subsubsection{Testing Stage}
Following the initial verification of the dynamic schedules produced, four test functions were chosen to be simulated and further verified to be functionally correct. This was carried out using a simple randomised testbench framework that compared the output of the circuit against an expected output generated by a System Verilog implementation of the test function. Issues encountered during the verification process, discussed further in sections \ref{sec:mul}, \ref{sec:ie}, \ref{sec:pow}, and \ref{sec:nr}, were solved. This meant the successful generation of the test functions. These were then synthesised and compared to equivalent test functions passed through the Dynamatic flow.

\subsubsection{Skills Aquired} %do I need this?

\section{Evaluation}
%TODO actually link the section 1.3
The aim of the project was to create a skeleton HLS framework to transform Julia sourcecode to digital hardware. The objectives outlines in Section 1.3 were achieved but challenges in developing the flow and deviations from the inital plan have resulted in the supported subset of the language being reduced.

The original evaluation plan included testing the HLS flow with the compilation using a matrix-vector multiplication. The challenge with the function is the flow is required to automatically generate a memory controller to store the matrix and vector information as opposed to the self contained variables used as input to the existing test functions.

The flow was able to avoid using the LLVM layer, staying within the realm of the Julia language. The main challenge resulting from this choice were the lack of access to existing optimisations to transform the typed IR. 

\subsubsection{Project Context}
Despite the challenges of the project and the limited support for the language, the achievements of the project should be considered. Existing HLS flows \cite{legup_intro}, \cite{dynamatics_p} are in development for years with teams of researchers constantly improving and expanding support for the language. We have created two distinct packages which will support the development of typed IR optimisations and the dynamic scheduling of Julia source code. We have demonstrated the viability of a HLS flow for the Julia language and have created a strong starting point to be developed in future work.

\iffalse
what were the objectives, were they achieved?
justify the resource size based on the IRs as input
explain lack of matrix vector multiply?
be persuasive about the skeleton framework introduced
	created a solid modular framework
	existing hls flows take significant time to develop
	
evaluate lack of frequency determination and buffers - combinatorial logic vs latency

critical evaluation of the work - compared to previous work, analysis, algos etc
relate to objectives
	how have objectives been fulfilled/not - how they have changed
advantages and disadvantages of the approach chosen - compared to related work
How does the scope differ from related work? - might be a good idea to compare IR to llvm, issues 
evidence of critical reflections - compare outcomes with objectives
	any changes between iterim and final should be explained self contained
	ref and summarise requirements
\fi

\iffalse
how successful, whats been achieved
identify what was worthwhile but be honest about limits of the work
describe the stuff not completed as further work
summarise and refer to other sections
	design choices and why
	difficult/clever part of the project
	why difficult, how overcome
	what was learnt
\fi

\section{Future Work}

Support for memory for arrays

Add IR optimisation passes to SSATools








\iffalse
- The evaluation plan should detail how you expect to measure the success of the project. 
- In particular it should document any tests that are required to ensure that the project deliverable(s)

- Julia has Continuous integration, unit tests on the package targeting edge cases and applying to all functions separately and together in the package
- comparisons to be made with other schedulers and hls flows depending on what we can get working
- it would be ideal to be able to implement some of the bench marks used by other HLS flows but owing to the complexity of the task and the time constraint, more likely try and implement simple functions that make use of addition, multiply, subtract blocks and memory management

- the scheduler should be able to generate correct grpahs, will be compared against schedules by nymble using the same algorithm
- binding and allocation will be tested by providing simple resource contraints in terms of area and functional blocks, deemed successful if schedules can still be rpoduced

- project will considered successful if the components are completed and are able to take a simple program, schdeule bind and allocate export to verilog that is actually synthesisable and can be run on an fpga

- include and exapand on matirx- vector multiplication test case


\section{Package Deliverables}
Julia has a testing package that aids development by simplifying the integration of unit tests for Continuous Integration (CI). Unit testing is a method for testing software that targets specific sections of that software as units. These units may be individual functions or subsets of a full application. The unit tests for each of the packages will verify the functionality of the whole by targeting the edge cases of individual functions isolated from the rest of the package, as well as collections of functions that perform a specific task.

For example, the \code{ci\_to\_f} function in the SSATools package has unit tests that focus on the following:

\begin{itemize}
    \item Producing the same output as the original function used to generate the CodeInfo.
    \item Successfully converting method invocations to standard calls.
    \item Successfully replacing PhiNodes and maintaining program control flow.
\end{itemize}

The allocation package will be tested using collections of simple functions and then compared to the correct allocated result. The scheduler will be tested using CDFGs with known schedules. The binding package will be tested by providing simple resource constraints on area and functional blocks.

Comparisons will be made with some existing HLS flows, like Nymble and LegUp, for the individual package outputs. This will involve creating some simpler functions that will target specific functional blocks like basic arithmetic and memory management in Julia, then running these functions through the different packages to obtain the outputs at each stage. Similar functions would then be created in C and run through the existing tools. Ideally, the results at the end of CDFG generation, allocation, scheduling and binding would then be compared to the project's outputs.


\section{Full Flow}
The project will be considered successful if the components are completed and organised into a full HLS flow. The flow will be evaluated using a simple Matrix-Vector program written in Julia. The exported Verilog code will be synthesised using the Yosys tool and run on an FPGA. A simple testbench will be constructed separate to the HLS flow to verify that the Verilog is functionally correct. The Verilog produced will also be compared to the output of existing tools.

\fi